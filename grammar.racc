class Scanner
  prechigh
    left '/'
    left '*'
    left '+' '-'
    nonassoc ELSE
    nonassoc LOWER_THAN_ELSE
  preclow

    options no_result_var

    token IDENTIFIER
    token CONSTANTI
    token CONSTANTF
    token INC_OP DEC_OP LE_OP GE_OP EQ_OP NE_OP
    token SUB_ASSIGN MUL_ASSIGN ADD_ASSIGN DIV_ASSIGN
    token SHL_ASSIGN SHR_ASSIGN
    token REM_ASSIGN
    token REM SHL SHR
    token AND OR
    token TYPE_NAME
    token INT FLOAT DOUBLE VOID
    token IF ELSE WHILE RETURN FOR DO

    start program

  rule

    conditional_expression
    : logical_or_expression                             { val[0] }

    logical_or_expression
    : logical_and_expression                            { val[0] }
    | logical_or_expression OR logical_and_expression

    logical_and_expression
    : comparison_expression                             { val[0] }
    | logical_and_expression AND comparison_expression



    shift_expression
    : additive_expression                               { val[0] }
    | shift_expression SHL additive_expression
    | shift_expression SHR additive_expression

    primary_expression
    : IDENTIFIER                                        { IdentifierExpr.new(val[0]) }
    | CONSTANTI                                         { ConstantIExpr.new(val[0]) }
    | CONSTANTF                                         { ConstantFExpr.new(val[0]) }
    | '(' expression ')'
    | IDENTIFIER '(' ')'
    | IDENTIFIER '(' argument_expression_list ')'

    postfix_expression
    : primary_expression                                { val[0] }
    | postfix_expression INC_OP
    | postfix_expression DEC_OP

    argument_expression_list
    : expression
    | argument_expression_list ',' expression

    unary_expression
    : postfix_expression                                { val[0] }
    | INC_OP unary_expression
    | DEC_OP unary_expression
    | unary_operator unary_expression

    unary_operator
    : '-'

    multiplicative_expression
    : unary_expression                                  { val[0] }
    | multiplicative_expression '*' unary_expression
    | multiplicative_expression '/' unary_expression
    | multiplicative_expression REM unary_expression

    additive_expression
    : multiplicative_expression                             { val[0] }
    | additive_expression '+' multiplicative_expression     { AddIExpr.new(val[0], val[2]) }
    | additive_expression '-' multiplicative_expression     { SubIExpr.new(val[0], val[2]) }

    comparison_expression
    : shift_expression                                  { val[0] }
    | comparison_expression '<' shift_expression
    | comparison_expression '>' shift_expression
    | comparison_expression LE_OP shift_expression
    | comparison_expression GE_OP shift_expression
    | comparison_expression EQ_OP shift_expression
    | comparison_expression NE_OP shift_expression

    expression
    : IDENTIFIER assignment_operator conditional_expression         { Assignment.new(val[0], val[2]) }
    | conditional_expression                                        { val[0] }

    assignment_operator
    : '='
    | MUL_ASSIGN
    | DIV_ASSIGN
    | REM_ASSIGN
    | SHL_ASSIGN
    | SHR_ASSIGN
    | ADD_ASSIGN
    | SUB_ASSIGN

    declaration
    : type_name declarator_list ';'                     { Declaration.new(val[0], val[1], lineno) }
    | type_name declarator_list '=' expression ';'      { Declaration.new(val[0], val[1], lineno, val[3]) }

    declarator_list
    : declarator                        { [ val[0] ] }
    | declarator_list ',' declarator    { val[0].push(val[2]) }

    type_name
    : VOID          { :void }
    | INT           { :integer }
    | FLOAT         { :float }
    | DOUBLE        { :float }

    declarator
    : IDENTIFIER                            { val[0] }
    | IDENTIFIER '(' parameter_list ')'     { "#{val[0]}(#{val[2]})" }
    | IDENTIFIER '(' ')'                    { "#{val[0]}()" }

    parameter_list
    : parameter_declaration
    | parameter_list ',' parameter_declaration

    parameter_declaration
    : type_name declarator

    statement
    : declaration
    | compound_statement
    | expression_statement
    | selection_statement
    | iteration_statement
    | jump_statement

    compound_statement
    : '{' '}'
    | '{' statement_list '}'                        { val[1] }

    statement_list
    : statement                                     { [val[0]] }
    | statement_list statement                      { val[0].push(val[1]) }

    expression_statement
    : ';'
    | expression ';'

    selection_statement
    : IF '(' expression ')' statement   =LOWER_THAN_ELSE
    | IF '(' expression ')' statement ELSE statement
    | FOR '(' expression ';' expression ';' expression ')' statement
    | FOR '(' expression ';' expression ';'            ')' statement
    | FOR '(' expression ';'            ';' expression ')' statement
    | FOR '(' expression ';'            ';'            ')' statement
    | FOR '('            ';' expression ';' expression ')' statement
    | FOR '('            ';' expression ';'            ')' statement
    | FOR '('            ';'            ';' expression ')' statement
    | FOR '('            ';'            ';'            ')' statement

    iteration_statement
    : WHILE '(' expression ')' statement
    | DO statement WHILE '(' expression ')' ';'

    jump_statement
    : RETURN ';'                    { Return.new }
    | RETURN expression ';'         { Return.new(val[1]) }

    program
    : external_declaration_list         { val[0].each { |ext_decl| puts "#{ext_decl.code(@scope)}" } }

    external_declaration_list
    : external_declaration                              { [val[0]] }
    | external_declaration_list external_declaration    { val[0].push(val[1]) }


    external_declaration
    : function_definition               { val[0] }
    | declaration

    function_definition
    : type_name declarator compound_statement               { Function.new(val[0], val[1], val[2]) }
end

---- header ----

require_relative 'scanner.rex'
require_relative '../core/core'

---- inner ----

def initialize
    @id_table = IdentifierTable.new
    @scope = Scope.new(@id_table);
end

def on_error(t, val, vstack)
    puts "Error: unexpected token (at line #{lineno}): #{val} [#{token_to_str(t)}]"
end

---- footer ----

if ARGV.size >= 1
    scanner = Scanner.new

    begin
        scanner.scan_file ARGV[0]
    rescue AlreadyDefinedError => msg
        STDERR.puts msg
    rescue IdentifierNotDefinedError => msg
        STDERR.puts msg
    end
else
    raise 'Error, no filename provided !'
end
